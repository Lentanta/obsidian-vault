Wgeb link: [leetcode grind75](https://www.techinterviewhandbook.org/grind75)
Link: [[10 Data structures & Algorithms]]

### [Two sum](https://leetcode.com/problems/two-sum)

**Good solution: using Map

- One-pass Hash table -> Create Map with values first and then check.
- Two-pass Hash table -> Create empty Map and then add value to check when iterate through the array.

### [Valid Parentheses](https://leetcode.com/problems/valid-parentheses)

**Good solution: using Stack**

### [Merge two sorted linked lists](https://leetcode.com/problems/merge-two-sorted-lists/)

**Solution: using while loop or recursive**
Don't care which list will merge to which. if the value of list1 is equal or smaller than list2. Then the `list1.next` will be list2.

- [Recursive solution](https://authorslog.com/blog/oXmSPEGRc3?title=21-merge-two-sorted-lists)
- Loop solution

### [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)

Best solution: using two pointers

1. Left < Right  => Max(left - right, result)
2. Left >= Right => leftPtr = rightPtr

### [Valid Palindrome](https://leetcode.com/problems/valid-palindrome)

Best solution: turn string into vaild string and then
`return string == reverse(string)`

### [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree)

Best solution: Breadth First Search

1. Push root into `Queue`
2. Swap `Left node` with `Right node`
3. Continue BFS

### [Valid Anagram](https://leetcode.com/problems/valid-anagram)

Solution: Using map

1. Add key is character and + value is number of character in s
2. Add key is character and - value is number of character in t
3. If value in map is not 0 then false

### [Binary Search](https://leetcode.com/problems/binary-search)

Link to: [[10.10 Binary search]]

## [Flood Fill](https://leetcode.com/problems/flood-fill)

Solution: DFS in 2D array.

```js
const fillDFS = (image, sr, sc, color, curClr) => {
 if (image[sr]?.[sc] !== curClr) return;
 image[sr][sc] = color;  
 
 if (sr + 1 <= image.length) {
  fillDFS(image, sr - 1, sc, color, curClr)
 }
 
 if (sr >= 0) {
  fillDFS(image, sr + 1, sc, color, curClr)
 }
 
 if (sc + 1 <= image[sr].length) {
  fillDFS(image, sr, sc - 1, color, curClr)
 }
 
 if (sc >= 0) {
  fillDFS(image, sr, sc + 1, color, curClr)
 }
};

const floodFill = function (image, sr, sc, color) {
 if (image[sr][sc] === color) return image;
 fillDFS(image, sr, sc, color, image[sr][sc])
 return image;
};
```

Recursive filling 4-directions, check boundary and fill new color.

## [Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree)

Solution: traverse to find the ancestor

 1. If p or q is equal to root then the root is Ancestor
 2. If not then go Left or Right

```js
const lowestCommonAncestor = function (root, p, q) {
 if (root.val < p.val && root.val < q.val) 
  return lowestCommonAncestor(root.right, p, q)
 if (root.val > p.val && root.val > q.val) 
  return lowestCommonAncestor(root.left, p, q)
 return root
}
```

## [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree)

Solution: DFS

 1. Check the deepest node to see if it banlanced
 2. Check upper node recursive

```js
const isBalancedDFSImpl = (root) => {
 if (!root) return [true, 0];
 
 const left = isBalancedDFSImpl(root.left);
 const right = isBalancedDFSImpl(root.right);

 const isLeftBalanced = left[0]
 const isRightBalanced = right[0]
 const totalHeight = Math.abs(left[1] - right[1])

 // Check left and right node
 // Check child node have total height
 const balance = isLeftBalanced && 
  isRightBalanced && 
  totalHeight <= 1;
  
 // Plus 1 is including the root node
 const height = Math.max(left[1], right[1]) + 1;
 return [balance, height]
};

const isBalanced = (root) => {
 return isBalancedDFSImpl(root)[0]
};
```
## [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks)

Solution: 1 slow pointer and 1 fast pointer
<https://en.wikipedia.org/wiki/Cycle_detection>
## [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks)

Solution: using 2 stack
![[two-stack-queue.png]]

## [First Bad Version](https://leetcode.com/problems/first-bad-version)

Solution: [[10.10 Binary search]]